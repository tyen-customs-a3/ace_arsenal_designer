<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACE3 Arsenal Simulation</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/info-panel.css">
</head>
<body>
    
    <div class="arsenal-container">
        <!-- Compact Category Sidebar -->
        <div class="category-sidebar">
            <button class="category-tab active" data-category="weapons" data-tooltip="Primary Weapons">‚óà</button>
            <button class="category-tab" data-category="handguns" data-tooltip="Handguns">‚óê</button>
            <button class="category-tab" data-category="launchers" data-tooltip="Launchers">‚óé</button>
            <button class="category-tab" data-category="backpacks" data-tooltip="Backpacks">‚ó¢</button>
            <button class="category-tab" data-category="vests" data-tooltip="Vests">‚óß</button>
        </div>

        <!-- Left Panel - Equipment List -->
        <div class="left-panel">
            <div class="left-panel-header">
                <input type="text" class="header-search full-width" id="leftSearch" placeholder="Search...">
            </div>
            
            
            <!-- Tree Controls outside and above list -->
            <div class="tree-controls-external">
                <button class="tree-toggle-btn" id="treeToggleBtn" onclick="toggleExpandCollapse()">+</button>
                <span class="tree-toggle-text" id="treeToggleText">Expand All</span>
                
                <!-- Sort controls in same row -->
                <div class="sort-control-group">
                    <label class="control-label">Sort by:</label>
                    <select id="sortingSelect">
                        <option value="sortByName">Name</option>
                        <option value="sortByMod">Mod</option>
                        <option value="sortByRange">Range</option>
                        <option value="sortByMass">Mass</option>
                    </select>
                    <button class="sort-order-toggle" id="sortOrderToggle" onclick="toggleSortOrder()" title="Toggle sort order">‚Üë</button>
                </div>
            </div>
            
            <div class="left-content">
                <ul class="tree-view" id="leftTreeView">
                    <!-- Category items will be populated here -->
                </ul>
            </div>
        </div>

        <!-- Vertical Panel Container -->
        <div class="side-panels-container">
            <!-- Compact Options Panel -->
            <div class="compact-options-panel" id="compactOptionsPanel">
                <!-- Options toggle header -->
                <div class="filter-toggle-header" onclick="toggleOptionsPanel()">
                    <span class="filter-toggle-text">Options</span>
                    <span class="filter-toggle-arrow" id="optionsToggleArrow">‚ñ∂</span>
                </div>
                
                <!-- Options content -->
                <div class="filter-content" id="optionsContent">
                    <!-- Group by Options -->
                    <div class="compact-filter-group">
                        <label class="compact-filter-label">Group by:</label>
                        <div class="compact-filter-radios">
                            <label class="compact-filter-option">
                                <input type="radio" name="groupByOption" value="none" onchange="updateGrouping('none')">
                                <span>None</span>
                            </label>
                            <label class="compact-filter-option">
                                <input type="radio" name="groupByOption" value="groupByMod" checked onchange="updateGrouping('groupByMod')">
                                <span>Mod</span>
                            </label>
                            <label class="compact-filter-option">
                                <input type="radio" name="groupByOption" value="groupByCaliber" onchange="updateGrouping('groupByCaliber')">
                                <span>Caliber</span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- View Mode Options -->
                    <div class="compact-filter-group">
                        <label class="compact-filter-label">View:</label>
                        <div class="compact-filter-radios">
                            <label class="compact-filter-option">
                                <input type="radio" name="viewMode" value="list" onchange="setViewMode('list')">
                                <span>üìÑ List</span>
                            </label>
                            <label class="compact-filter-option">
                                <input type="radio" name="viewMode" value="hierarchy" checked onchange="setViewMode('hierarchy')">
                                <span>üå≥ Tree</span>
                            </label>
                            <label class="compact-filter-option">
                                <input type="radio" name="viewMode" value="variants" onchange="setViewMode('variants')">
                                <span>üé® Variants</span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Icon Display Options -->
                    <div class="compact-filter-group">
                        <label class="compact-filter-label">Icons:</label>
                        <div class="compact-filter-checkboxes">
                            <label class="filter-checkbox">
                                <input type="checkbox" id="showPreviewIcon" onchange="togglePreviewIcon(this.checked)">
                                <span>Preview Icon</span>
                            </label>
                            <label class="filter-checkbox">
                                <input type="checkbox" id="showModIcon" onchange="toggleModIcon(this.checked)">
                                <span>Mod Icon</span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Row Spacing Options -->
                    <div class="compact-filter-group">
                        <label class="compact-filter-label">Spacing:</label>
                        <div class="compact-filter-radios">
                            <label class="compact-filter-option">
                                <input type="radio" name="spacingOption" value="compact" onchange="changeSpacing('compact')">
                                <span>Compact</span>
                            </label>
                            <label class="compact-filter-option">
                                <input type="radio" name="spacingOption" value="general" checked onchange="changeSpacing('general')">
                                <span>General</span>
                            </label>
                            <label class="compact-filter-option">
                                <input type="radio" name="spacingOption" value="spacious" onchange="changeSpacing('spacious')">
                                <span>Spacious</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Compact Filter Panel -->
            <div class="compact-filter-panel" id="compactFilterPanel">
                <!-- Filter toggle header -->
                <div class="filter-toggle-header" onclick="toggleFilterPanel()">
                    <span class="filter-toggle-text">Filters</span>
                    <span class="filter-toggle-arrow" id="filterToggleArrow">‚ñ∂</span>
                </div>
                
                <!-- Filter content -->
                <div class="filter-content" id="filterContent">
                    <!-- Compact Filter Groups -->
                    <div class="compact-filter-group">
                        <label class="compact-filter-label">Mod:</label>
                        <div class="compact-filter-checkboxes" id="modFilters">
                            <!-- Populated dynamically -->
                        </div>
                    </div>
                    
                    <div class="compact-filter-group">
                        <label class="compact-filter-label">Caliber:</label>
                        <div class="compact-filter-checkboxes" id="caliberFilters">
                            <!-- Populated dynamically -->
                        </div>
                    </div>
                    
                    <div class="compact-filter-group">
                        <label class="compact-filter-label">Variants:</label>
                        <div class="compact-filter-radios">
                            <label class="compact-filter-option">
                                <input type="radio" name="variantFilter" value="all" checked>
                                <span>All</span>
                            </label>
                            <label class="compact-filter-option">
                                <input type="radio" name="variantFilter" value="base-only">
                                <span>Base</span>
                            </label>
                            <label class="compact-filter-option">
                                <input type="radio" name="variantFilter" value="variants-only">
                                <span>Variants</span>
                            </label>
                        </div>
                    </div>
                    
                    <button class="clear-filters-btn" onclick="clearAllFilters()" title="Clear all filters">Clear All Filters</button>
                </div>
            </div>

            <!-- Compact Stats Panel -->
            <div class="compact-stats-panel" id="compactStatsPanel">
                <!-- Stats toggle header -->
                <div class="filter-toggle-header" onclick="toggleStatsPanel()">
                    <span class="filter-toggle-text">Statistics</span>
                    <span class="filter-toggle-arrow" id="statsToggleArrow">‚ñ∂</span>
                </div>
                
                <!-- Stats content -->
                <div class="filter-content" id="statsContent">
                    <div class="stat-item">
                        <span class="stat-label">Name:</span>
                        <span class="stat-value" id="statName">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Class Name:</span>
                        <span class="stat-value" id="statClassName">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Mod:</span>
                        <span class="stat-value" id="statMod">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Damage:</span>
                        <span class="stat-value" id="statDamage">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Range:</span>
                        <span class="stat-value" id="statRange">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Mass:</span>
                        <span class="stat-value" id="statMass">-</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Capacity:</span>
                        <span class="stat-value" id="statCapacity">-</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel - Selected Item Options -->
        <div class="right-panel">
            <div class="right-panel-header">
                <input type="text" class="header-search full-width" id="rightSearch" placeholder="Search...">
            </div>
            <div class="right-content">
                <ul class="tree-view" id="rightTreeView">
                    <!-- Attachments and magazines will be populated here -->
                </ul>
            </div>
        </div>


        <!-- Attachment Category Sidebar -->
        <div class="attachment-sidebar">
            <button class="attachment-tab active" data-attachment="attachments" data-tooltip="Attachments">‚öô</button>
            <button class="attachment-tab" data-attachment="magazines" data-tooltip="Magazines">‚óà</button>
        </div>

        <!-- Central Area - Info Panel -->
        <div class="central-area">
            <div class="info-panel-static" id="infoPanel">
                <div class="info-panel-header">
                    <h3>New!</h3>
                </div>
                <div class="info-panel-content">
                    <div class="view-mode-info">
                        <h4>List View</h4>
                        <p>Simple flat list of all items. No hierarchy or grouping structure.</p>
                    </div>
                    <div class="view-mode-info">
                        <h4>Tree View (Hierarchy)</h4>
                        <p>Shows class inheritance relationships. Parent classes contain their child classes in an expandable tree structure.</p>
                    </div>
                    <div class="view-mode-info">
                        <h4>Variants View</h4>
                        <p>Groups base weapons with their texture variants. Base weapons are expandable with variants shown as children.</p>
                    </div>
                    <div class="grouping-info">
                        <h4>Group By Options</h4>
                        <p><strong>None:</strong> No additional grouping</p>
                        <p><strong>Mod:</strong> Group items by their source mod</p>
                        <p><strong>Caliber:</strong> Group weapons/magazines by ammunition type</p>
                    </div>
                    <div class="features-info">
                        <h4>Features</h4>
                        <p>‚Ä¢ <strong>Options Panel:</strong> Configure icons, spacing, and view modes</p>
                        <p>‚Ä¢ <strong>Filters Panel:</strong> Filter by mod, caliber, and variant type</p>
                        <p>‚Ä¢ <strong>Icon Display:</strong> Toggle preview and mod icons on items</p>
                        <p>‚Ä¢ <strong>Keyboard Navigation:</strong> Use arrow keys to navigate items</p>
                    </div>
                </div>
            </div>
        </div>


        <div class="timing" id="timing">Ready</div>
    </div>

    <script type="module">
        // Import data and algorithms
        import { getMockItems } from './data.js';
        import * as algorithms from './algorithms.js';
        import * as groupingAlgorithms from './algorithms/grouping.js';
        import * as multiGrouping from './algorithms/multiGrouping.js';
        import * as hierarchyAlgorithms from './algorithms/hierarchy.js';
        
        // Import simple tree components  
        import { 
            createTreeData,
            renderSimpleTree,
            toggleTreeGroup,
            selectTreeItem,
            initializeKeyboardNavigation,
            clearPanelFocus,
            focusFirstItem,
            restoreFocusAfterViewChange
        } from './ui/simpleTree.js';
        
        // Global state - simplified
        let currentItems = [];
        let filteredItems = [];
        let selectedCategory = 'weapons';
        let selectedRightCategory = 'attachments';
        let selectedItem = null;
        let currentSortOrder = 'asc';
        let currentExpandState = false;

        // Filter state
        let activeFilters = {
            mods: new Set(),
            calibers: new Set(),
            variants: 'all',
        };

        // Category filtering
        function filterItemsByCategory(category) {
            const categoryItems = currentItems.filter(item => item.category === category);
            return applyActiveFilters(categoryItems);
        }

        // Apply all active filters to items
        function applyActiveFilters(items) {
            return items.filter(item => {
                // Mod filter
                if (activeFilters.mods.size > 0 && !activeFilters.mods.has(item.mod || 'Unknown')) {
                    return false;
                }

                // Caliber filter
                if (activeFilters.calibers.size > 0 && !activeFilters.calibers.has(item.caliber || 'Unknown')) {
                    return false;
                }

                // Variant filter
                if (activeFilters.variants === 'base-only' && item.variant) {
                    return false;
                }
                if (activeFilters.variants === 'variants-only' && !item.variant) {
                    return false;
                }

                return true;
            });
        }

        // Generate filter options dynamically based on current category
        function populateFilterOptions(category) {
            const categoryItems = currentItems.filter(item => item.category === category);
            
            // Get unique values for each filter type
            const mods = [...new Set(categoryItems.map(item => item.mod || 'Unknown'))].sort();
            const calibers = [...new Set(categoryItems.map(item => item.caliber).filter(c => c))].sort();

            // Populate mod filters
            const modContainer = document.getElementById('modFilters');
            modContainer.innerHTML = mods.map(mod => `
                <label class="filter-checkbox">
                    <input type="checkbox" value="${mod}" onchange="toggleFilter('mods', '${mod}', this.checked)">
                    <span>${mod}</span>
                </label>
            `).join('');

            // Populate caliber filters
            const caliberContainer = document.getElementById('caliberFilters');
            caliberContainer.innerHTML = calibers.map(caliber => `
                <label class="filter-checkbox">
                    <input type="checkbox" value="${caliber}" onchange="toggleFilter('calibers', '${caliber}', this.checked)">
                    <span>${caliber}</span>
                </label>
            `).join('');

        }

        // Toggle individual filter
        function toggleFilter(filterType, value, isChecked) {
            if (isChecked) {
                activeFilters[filterType].add(value);
            } else {
                activeFilters[filterType].delete(value);
            }
            updateFilteredItems();
        }

        // Clear all filters
        function clearAllFilters() {
            activeFilters.mods.clear();
            activeFilters.calibers.clear();
            activeFilters.variants = 'all';

            // Reset UI
            document.querySelectorAll('.compact-filter-checkboxes input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            document.querySelector('input[name="variantFilter"][value="all"]').checked = true;

            updateFilteredItems();
        }

        // Update filtered items and refresh display
        function updateFilteredItems() {
            filteredItems = filterItemsByCategory(selectedCategory);
            renderTreeView(filteredItems, 'leftTreeView');
        }

        // Filter compatible accessories for selected weapon using weaponSlots
        function getCompatibleAccessories(weapon) {
            if (!weapon) return [];
            
            const attachments = currentItems.filter(item => item.category === 'attachments');
            console.log(`üîß Found ${attachments.length} total attachments in currentItems`);
            
            // Filter attachments by weapon slot compatibility
            if (weapon.weaponSlots && weapon.weaponSlots.length > 0) {
                const compatible = attachments.filter(attachment => {
                    if (!attachment.weaponSlots || attachment.weaponSlots.length === 0) {
                        return false; // Attachment has no slot info, assume incompatible
                    }
                    
                    // Check if any weapon slot matches any attachment slot
                    return weapon.weaponSlots.some(weaponSlot => 
                        attachment.weaponSlots.some(attachmentSlot => 
                            weaponSlot === attachmentSlot
                        )
                    );
                });
                console.log(`üîß Found ${compatible.length} compatible attachments:`, compatible.map(a => a.displayName));
                return compatible;
            }
            
            // If weapon has no slot info, show no attachments (strict compatibility)
            console.log('‚ö†Ô∏è Weapon has no weaponSlots defined, showing no attachments');
            return [];
        }

        // Filter compatible magazines for selected weapon using magazineWells
        function getCompatibleMagazines(weapon) {
            if (!weapon) return [];
            
            const magazines = currentItems.filter(item => item.category === 'magazines');
            console.log(`üì¶ Found ${magazines.length} total magazines in currentItems`);
            
            // Filter magazines by magazineWells compatibility
            if (weapon.magazineWells && weapon.magazineWells.length > 0) {
                const compatible = magazines.filter(magazine => {
                    if (!magazine.magazineWells || magazine.magazineWells.length === 0) {
                        return false; // Magazine has no well info, assume incompatible
                    }
                    
                    // Check if any weapon magazine well matches any magazine well
                    return weapon.magazineWells.some(weaponWell => 
                        magazine.magazineWells.some(magWell => 
                            weaponWell === magWell
                        )
                    );
                });
                console.log(`üì¶ Found ${compatible.length} compatible magazines:`, compatible.map(m => m.displayName));
                return compatible;
            }
            
            // If weapon has no magazine well info, show no magazines (strict compatibility)
            console.log('‚ö†Ô∏è Weapon has no magazineWells defined, showing no magazines');
            return [];
        }

        // Update right panel with compatible accessories
        function updateCompatibleAccessories(weapon) {
            console.log('üî´ Weapon selected:', weapon.displayName);
            console.log('üì¶ Magazine wells:', weapon.magazineWells);
            console.log('üîß Weapon slots:', weapon.weaponSlots);
            console.log('üéØ Right panel category:', selectedRightCategory);
            
            if (selectedRightCategory === 'attachments') {
                const compatibleAttachments = getCompatibleAccessories(weapon);
                console.log('‚úÖ Compatible attachments found:', compatibleAttachments.length);
                console.log('üìã Sample attachments:', compatibleAttachments.slice(0, 3).map(a => ({
                    name: a.displayName,
                    weaponSlots: a.weaponSlots,
                    subcategory: a.subcategory
                })));
                renderTreeView(compatibleAttachments, 'rightTreeView', false);
            } else if (selectedRightCategory === 'magazines') {
                const compatibleMagazines = getCompatibleMagazines(weapon);
                console.log('‚úÖ Compatible magazines found:', compatibleMagazines.length);
                console.log('üìã Sample magazines:', compatibleMagazines.slice(0, 3).map(m => ({
                    name: m.displayName,
                    magazineWells: m.magazineWells,
                    caliber: m.caliber
                })));
                renderTreeView(compatibleMagazines, 'rightTreeView', false);
            }
        }


        // Simple tree view rendering
        function renderTreeView(items, containerId, useGrouping = true) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const startTime = performance.now();

            // Get current UI state
            const viewMode = document.querySelector('input[name="viewMode"]:checked')?.value || 'hierarchy';
            const sortMethod = document.getElementById('sortingSelect').value;
            const sortOrder = currentSortOrder;
            const primaryGrouping = document.querySelector('input[name="groupByOption"]:checked')?.value || 'none';

            let groupingFunction = null;
            let sortingFunction = null;

            // Get sorting function
            if (sortMethod && algorithms[sortMethod]) {
                sortingFunction = (items) => algorithms[sortMethod](items, sortOrder);
            }

            // Determine grouping and view mode
            // Priority: User grouping selection > View mode default behavior
            
            if (primaryGrouping !== 'none') {
                // User has selected a grouping - apply it as top-level grouping
                // View mode will be applied within each group
                useGrouping = true;
                groupingFunction = algorithms[primaryGrouping];
            } else {
                // No user grouping selected - let view mode handle all organization
                if (viewMode === 'variants' || viewMode === 'hierarchy') {
                    // Special view modes that handle their own organization
                    useGrouping = true;
                    groupingFunction = null; // No top-level grouping, let view mode handle everything
                } else {
                    // Flat list with no grouping
                    useGrouping = false;
                }
            }

            // Create tree data structure - view mode determines how items are displayed within groups
            const hasPrimaryGrouping = primaryGrouping !== 'none';
            const treeData = createTreeData(items, useGrouping, groupingFunction, sortingFunction, viewMode, hasPrimaryGrouping);
            
            // Render simple tree
            const html = `<ul class="tree-view">${renderSimpleTree(treeData, viewMode)}</ul>`;
            
            const endTime = performance.now();
            document.getElementById('timing').textContent = `${(endTime - startTime).toFixed(2)}ms`;

            container.innerHTML = html;
            
            // Clear focus when tree content changes, then restore it
            clearPanelFocus(containerId);
            
            // Use setTimeout to allow DOM to update before restoring focus
            setTimeout(() => {
                restoreFocusAfterViewChange(containerId);
            }, 0);
        }

        // Simple tree toggle - delegates to simpleTree.js
        function toggleTreeNodeExpansion(nodeId) {
            toggleTreeGroup(nodeId);
        }

        // Item selection and stats display
        function selectItem(element) {
            console.log('üñ±Ô∏è Item clicked!', element);
            
            // Remove previous selection
            document.querySelectorAll('.tree-item').forEach(item => item.classList.remove('selected'));
            document.querySelectorAll('.tree-parent').forEach(item => item.classList.remove('selected'));
            element.classList.add('selected');

            try {
                selectedItem = JSON.parse(element.dataset.item);
                console.log('‚úÖ Item parsed:', selectedItem.displayName, 'Category:', selectedItem.category);
                
                updateStats(selectedItem);
                
                
                // Update right panel with compatible accessories when weapon is selected
                if (selectedItem.category === 'weapons') {
                    console.log('üî´ Weapon detected, updating right panel...');
                    console.log('üîç Current items total:', currentItems.length);
                    console.log('üîç Items by category:', currentItems.reduce((acc, item) => {
                        acc[item.category] = (acc[item.category] || 0) + 1;
                        return acc;
                    }, {}));
                    updateCompatibleAccessories(selectedItem);
                } else {
                    console.log('üö´ Not a weapon, category:', selectedItem.category);
                }
            } catch (e) {
                console.warn('Could not parse item data:', e);
            }
        }

        function updateStats(item) {
            // Clear all stat fields first
            const allStatFields = ['statName', 'statClassName', 'statMod', 'statDamage', 'statRange', 'statMass', 'statCapacity', 'statCaliber', 'statArmor', 'statRateOfFire', 'statZoom', 'statRecoil'];
            allStatFields.forEach(fieldId => {
                const element = document.getElementById(fieldId);
                if (element) {
                    element.parentElement.style.display = 'none';
                }
            });

            // Always show basic info
            document.getElementById('statName').textContent = item.displayName || item.name || '-';
            document.getElementById('statName').parentElement.style.display = 'block';
            
            document.getElementById('statClassName').textContent = item.className || '-';
            document.getElementById('statClassName').parentElement.style.display = 'block';
            
            document.getElementById('statMod').textContent = item.mod || '-';
            document.getElementById('statMod').parentElement.style.display = 'block';

            // Show category-specific stats
            const category = item.category || item.type;
            
            if (category === 'weapons' || category === 'weapon' || category === 'handguns' || category === 'handgun' || category === 'launchers' || category === 'launcher') {
                // Weapons: range, mass, caliber, rate of fire
                if (item.range || item.properties?.range) {
                    document.getElementById('statRange').textContent = `${item.range || item.properties.range}m`;
                    document.getElementById('statRange').parentElement.style.display = 'block';
                }
                
                if (item.mass || item.properties?.mass) {
                    document.getElementById('statMass').textContent = `${((item.mass || item.properties.mass)/1000).toFixed(2)}kg`;
                    document.getElementById('statMass').parentElement.style.display = 'block';
                }
                
                if (item.caliber || item.properties?.caliber) {
                    // Create caliber field if it doesn't exist
                    let caliberElement = document.getElementById('statCaliber');
                    if (!caliberElement) {
                        const caliberDiv = document.createElement('div');
                        caliberDiv.className = 'stat-item';
                        caliberDiv.innerHTML = '<span class="stat-label">Caliber:</span><span class="stat-value" id="statCaliber">-</span>';
                        document.getElementById('statMod').parentElement.parentNode.appendChild(caliberDiv);
                        caliberElement = document.getElementById('statCaliber');
                    }
                    caliberElement.textContent = item.caliber || item.properties.caliber;
                    caliberElement.parentElement.style.display = 'block';
                }
                
                if (item.rateOfFire || item.properties?.rateOfFire) {
                    // Create rate of fire field if it doesn't exist
                    let rofElement = document.getElementById('statRateOfFire');
                    if (!rofElement) {
                        const rofDiv = document.createElement('div');
                        rofDiv.className = 'stat-item';
                        rofDiv.innerHTML = '<span class="stat-label">Rate of Fire:</span><span class="stat-value" id="statRateOfFire">-</span>';
                        document.getElementById('statMod').parentElement.parentNode.appendChild(rofDiv);
                        rofElement = document.getElementById('statRateOfFire');
                    }
                    rofElement.textContent = `${item.rateOfFire || item.properties.rateOfFire} rpm`;
                    rofElement.parentElement.style.display = 'block';
                }
                
            } else if (category === 'vests' || category === 'vest') {
                // Vests: armor, maximumLoad, mass
                if (item.armor || item.properties?.armor) {
                    // Create armor field if it doesn't exist
                    let armorElement = document.getElementById('statArmor');
                    if (!armorElement) {
                        const armorDiv = document.createElement('div');
                        armorDiv.className = 'stat-item';
                        armorDiv.innerHTML = '<span class="stat-label">Armor:</span><span class="stat-value" id="statArmor">-</span>';
                        document.getElementById('statMod').parentElement.parentNode.appendChild(armorDiv);
                        armorElement = document.getElementById('statArmor');
                    }
                    armorElement.textContent = item.armor || item.properties.armor;
                    armorElement.parentElement.style.display = 'block';
                }
                
                if (item.maximumLoad || item.properties?.maximumLoad) {
                    document.getElementById('statCapacity').parentElement.querySelector('.stat-label').textContent = 'Max Load:';
                    document.getElementById('statCapacity').textContent = `${item.maximumLoad || item.properties.maximumLoad}kg`;
                    document.getElementById('statCapacity').parentElement.style.display = 'block';
                }
                
                if (item.mass || item.properties?.mass) {
                    document.getElementById('statMass').textContent = `${((item.mass || item.properties.mass)/1000).toFixed(2)}kg`;
                    document.getElementById('statMass').parentElement.style.display = 'block';
                }
                
            } else if (category === 'backpacks' || category === 'backpack') {
                // Backpacks: maximumLoad, mass
                if (item.maximumLoad || item.properties?.maximumLoad) {
                    document.getElementById('statCapacity').parentElement.querySelector('.stat-label').textContent = 'Max Load:';
                    document.getElementById('statCapacity').textContent = `${item.maximumLoad || item.properties.maximumLoad}kg`;
                    document.getElementById('statCapacity').parentElement.style.display = 'block';
                }
                
                if (item.mass || item.properties?.mass) {
                    document.getElementById('statMass').textContent = `${((item.mass || item.properties.mass)/1000).toFixed(2)}kg`;
                    document.getElementById('statMass').parentElement.style.display = 'block';
                }
                
            } else if (category === 'magazines' || category === 'magazine') {
                // Magazines: caliber, capacity, mass
                if (item.caliber || item.properties?.caliber) {
                    // Create caliber field if it doesn't exist
                    let caliberElement = document.getElementById('statCaliber');
                    if (!caliberElement) {
                        const caliberDiv = document.createElement('div');
                        caliberDiv.className = 'stat-item';
                        caliberDiv.innerHTML = '<span class="stat-label">Caliber:</span><span class="stat-value" id="statCaliber">-</span>';
                        document.getElementById('statMod').parentElement.parentNode.appendChild(caliberDiv);
                        caliberElement = document.getElementById('statCaliber');
                    }
                    caliberElement.textContent = item.caliber || item.properties.caliber;
                    caliberElement.parentElement.style.display = 'block';
                }
                
                if (item.capacity || item.properties?.capacity) {
                    document.getElementById('statCapacity').parentElement.querySelector('.stat-label').textContent = 'Capacity:';
                    document.getElementById('statCapacity').textContent = item.capacity || item.properties.capacity;
                    document.getElementById('statCapacity').parentElement.style.display = 'block';
                }
                
                if (item.mass || item.properties?.mass) {
                    document.getElementById('statMass').textContent = `${((item.mass || item.properties.mass)/1000).toFixed(2)}kg`;
                    document.getElementById('statMass').parentElement.style.display = 'block';
                }
                
            } else if (category === 'attachments' || category === 'attachment') {
                // Attachments: mass, zoom, recoil modifier, sway modifier
                if (item.mass || item.properties?.mass) {
                    document.getElementById('statMass').textContent = `${((item.mass || item.properties.mass)/1000).toFixed(2)}kg`;
                    document.getElementById('statMass').parentElement.style.display = 'block';
                }
                
                if (item.zoom || item.properties?.zoom) {
                    // Create zoom field if it doesn't exist
                    let zoomElement = document.getElementById('statZoom');
                    if (!zoomElement) {
                        const zoomDiv = document.createElement('div');
                        zoomDiv.className = 'stat-item';
                        zoomDiv.innerHTML = '<span class="stat-label">Zoom:</span><span class="stat-value" id="statZoom">-</span>';
                        document.getElementById('statMod').parentElement.parentNode.appendChild(zoomDiv);
                        zoomElement = document.getElementById('statZoom');
                    }
                    zoomElement.textContent = `${item.zoom || item.properties.zoom}x`;
                    zoomElement.parentElement.style.display = 'block';
                }
                
                if (item.recoilModifier || item.properties?.recoilModifier) {
                    // Create recoil field if it doesn't exist
                    let recoilElement = document.getElementById('statRecoil');
                    if (!recoilElement) {
                        const recoilDiv = document.createElement('div');
                        recoilDiv.className = 'stat-item';
                        recoilDiv.innerHTML = '<span class="stat-label">Recoil:</span><span class="stat-value" id="statRecoil">-</span>';
                        document.getElementById('statMod').parentElement.parentNode.appendChild(recoilDiv);
                        recoilElement = document.getElementById('statRecoil');
                    }
                    recoilElement.textContent = `${((item.recoilModifier || item.properties.recoilModifier) * 100).toFixed(0)}%`;
                    recoilElement.parentElement.style.display = 'block';
                }
            }
        }


        // Category tab handling
        function switchCategory(category) {
            selectedCategory = category;
            
            // Update tab appearance
            document.querySelectorAll('.category-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`[data-category="${category}"]`).classList.add('active');
            
            // Populate filter options for new category
            populateFilterOptions(category);
            
            // Filter and display items
            filteredItems = filterItemsByCategory(category);
            renderTreeView(filteredItems, 'leftTreeView');
        }

        function switchRightCategory(category) {
            console.log('üîÑ Switching right category to:', category);
            selectedRightCategory = category;
            
            // Update tab appearance
            document.querySelectorAll('.attachment-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`[data-attachment="${category}"]`).classList.add('active');
            
            // Filter and display items based on selected weapon compatibility
            if (selectedItem && selectedItem.category === 'weapons') {
                console.log('üî´ Weapon is selected, filtering for compatibility...');
                updateCompatibleAccessories(selectedItem);
            } else {
                console.log('üîç No weapon selected, showing all', category);
                // If no weapon selected, show all items of this category
                const rightItems = filterItemsByCategory(category);
                console.log('üì¶ Right items found:', rightItems.length);
                renderTreeView(rightItems, 'rightTreeView', false); // No grouping for right panel
            }
        }


        // Data generation
        function regenerateData() {
            currentItems = generateMockItems(200);
            switchCategory(selectedCategory);
            switchRightCategory(selectedRightCategory);
            clearSelection();
        }

        // New UI control functions
        function applySorting(items, method, order) {
            const sortFunction = algorithms[method];
            if (sortFunction) {
                return sortFunction(items, order);
            }
            return items;
        }
        
        function applyMultiGrouping(items, primary, secondary) {
            // Convert string names to actual grouping functions
            const primaryFunction = algorithms[primary];
            const secondaryFunction = getSecondaryGroupingFunction(secondary);
            
            if (primaryFunction && secondaryFunction) {
                return multiGrouping.groupByMultiple(items, primaryFunction, secondaryFunction);
            } else if (primaryFunction) {
                return primaryFunction(items);
            }
            
            return { 'All Items': items };
        }
        
        function getSecondaryGroupingFunction(secondaryName) {
            const mapping = {
                'groupByMod': algorithms.groupByMod,
                'groupByCaliber': algorithms.groupByCaliber
            };
            return mapping[secondaryName] || null;
        }
        
        function toggleInheritanceView() {
            // Toggle between flat list and inheritance hierarchy
            const currentView = document.querySelector('.view-mode-toggle.active')?.dataset.view;
            if (currentView === 'list') {
                setViewMode('hierarchy');
            } else {
                setViewMode('list');
            }
        }
        
        function setViewMode(mode) {
            // Update radio button selection
            document.querySelector(`input[name="viewMode"][value="${mode}"]`).checked = true;
            
            // Show/hide collapse toggle based on view mode
            const collapseToggleContainer = document.getElementById('treeToggleBtn').parentElement;
            const collapseToggleBtn = document.getElementById('treeToggleBtn');
            const collapseToggleText = document.getElementById('treeToggleText');
            
            if (mode === 'list') {
                // Hide collapse toggle for flat list view
                collapseToggleBtn.style.display = 'none';
                collapseToggleText.style.display = 'none';
            } else {
                // Show collapse toggle for hierarchy and variants views
                collapseToggleBtn.style.display = 'flex';
                collapseToggleText.style.display = 'inline';
            }
            
            renderTreeView(filteredItems, 'leftTreeView');
        }

        function runGrouping() {
            renderTreeView(filteredItems, 'leftTreeView');
        }

        function updateGrouping(value) {
            // Update radio button selection
            document.querySelector(`input[name="groupByOption"][value="${value}"]`).checked = true;
            renderTreeView(filteredItems, 'leftTreeView');
        }

        function clearSelection() {
            // Clear visual selection
            document.querySelectorAll('.tree-item').forEach(item => item.classList.remove('selected'));
            document.querySelectorAll('.tree-parent').forEach(item => item.classList.remove('selected'));
            
            // Clear selected item
            selectedItem = null;
            
            // Clear stats
            ['statName', 'statClassName', 'statMod', 'statDamage', 'statRange', 'statMass', 'statCapacity'].forEach(id => {
                document.getElementById(id).textContent = '-';
            });

            // Clear loadout
            currentLoadout = { weapon: null, handgun: null, backpack: null, vest: null, attachments: [] };
            document.getElementById('previewWeapon').textContent = 'Primary: None';
            document.getElementById('previewHandgun').textContent = 'Handgun: None';
            document.getElementById('previewBackpack').textContent = 'Backpack: None';
            document.getElementById('previewVest').textContent = 'Vest: None';
            document.getElementById('previewAttachments').textContent = 'Attachments: None';
            
            // Reset right panel to show all items of current category
            const rightItems = filterItemsByCategory(selectedRightCategory);
            renderTreeView(rightItems, 'rightTreeView', false);
        }

        // Simple expand/collapse all
        function expandAllGroups() {
            document.querySelectorAll('.tree-children').forEach(el => {
                el.style.display = 'block';
            });
            document.querySelectorAll('.tree-toggle').forEach(el => {
                el.textContent = '‚ñº';
            });
        }

        function collapseAllGroups() {
            document.querySelectorAll('.tree-children').forEach(el => {
                el.style.display = 'none';
            });
            document.querySelectorAll('.tree-toggle').forEach(el => {
                el.textContent = '‚ñ∂';
            });
        }

        // New compact toggle functions
        function toggleSortOrder() {
            currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
            const button = document.getElementById('sortOrderToggle');
            button.textContent = currentSortOrder === 'asc' ? '‚Üë' : '‚Üì';
            button.title = currentSortOrder === 'asc' ? 'Ascending order - click for descending' : 'Descending order - click for ascending';
            renderTreeView(filteredItems, 'leftTreeView');
        }

        function toggleExpandCollapse() {
            const button = document.getElementById('treeToggleBtn');
            const text = document.getElementById('treeToggleText');
            if (currentExpandState) {
                collapseAllGroups();
                button.textContent = '+';
                text.textContent = 'Expand All';
                currentExpandState = false;
            } else {
                expandAllGroups();
                button.textContent = '‚àí';
                text.textContent = 'Collapse All';
                currentExpandState = true;
            }
        }

        function toggleFilterPanel() {
            const panel = document.getElementById('compactFilterPanel');
            const content = document.getElementById('filterContent');
            const arrow = document.getElementById('filterToggleArrow');
            
            panel.classList.toggle('expanded');
            
            if (panel.classList.contains('expanded')) {
                content.style.display = 'block';
                arrow.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                arrow.textContent = '‚ñ∂';
            }
        }

        function toggleStatsPanel() {
            const panel = document.getElementById('compactStatsPanel');
            const content = document.getElementById('statsContent');
            const arrow = document.getElementById('statsToggleArrow');
            
            panel.classList.toggle('expanded');
            
            if (panel.classList.contains('expanded')) {
                content.style.display = 'block';
                arrow.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                arrow.textContent = '‚ñ∂';
            }
        }

        function toggleOptionsPanel() {
            const panel = document.getElementById('compactOptionsPanel');
            const content = document.getElementById('optionsContent');
            const arrow = document.getElementById('optionsToggleArrow');
            
            panel.classList.toggle('expanded');
            
            if (panel.classList.contains('expanded')) {
                content.style.display = 'block';
                arrow.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                arrow.textContent = '‚ñ∂';
            }
        }

        // Options state
        let displayOptions = {
            showPreviewIcon: false,
            showModIcon: false,
            spacing: 'general'
        };
        
        // Make display options globally available
        window.displayOptions = displayOptions;

        function togglePreviewIcon(enabled) {
            displayOptions.showPreviewIcon = enabled;
            renderTreeView(filteredItems, 'leftTreeView');
            // Update right panel if it has items
            const rightTreeView = document.getElementById('rightTreeView');
            if (rightTreeView && rightTreeView.children.length > 0) {
                if (selectedItem && selectedItem.category === 'weapons') {
                    updateCompatibleAccessories(selectedItem);
                } else {
                    const rightItems = filterItemsByCategory(selectedRightCategory);
                    renderTreeView(rightItems, 'rightTreeView', false);
                }
            }
        }

        function toggleModIcon(enabled) {
            displayOptions.showModIcon = enabled;
            renderTreeView(filteredItems, 'leftTreeView');
            // Update right panel if it has items
            const rightTreeView = document.getElementById('rightTreeView');
            if (rightTreeView && rightTreeView.children.length > 0) {
                if (selectedItem && selectedItem.category === 'weapons') {
                    updateCompatibleAccessories(selectedItem);
                } else {
                    const rightItems = filterItemsByCategory(selectedRightCategory);
                    renderTreeView(rightItems, 'rightTreeView', false);
                }
            }
        }

        function changeSpacing(spacing) {
            displayOptions.spacing = spacing;
            
            // Update left panel
            const leftTreeView = document.getElementById('leftTreeView');
            leftTreeView.className = `tree-view spacing-${spacing}`;
            
            // Update right panel
            const rightTreeView = document.getElementById('rightTreeView');
            rightTreeView.className = `tree-view spacing-${spacing}`;
        }


        // Hover preview functionality
        let hoverPreviewElement = null;
        let hoverPreviewTimeout = null;

        function showItemPreview(event, element) {
            // Only show preview for items with data
            if (!element.dataset.item) return;
            
            // Clear any existing timeout
            clearTimeout(hoverPreviewTimeout);
            
            // Add small delay to prevent flickering
            hoverPreviewTimeout = setTimeout(() => {
                try {
                    const itemData = JSON.parse(element.dataset.item);
                    
                    // Create preview element if it doesn't exist
                    if (!hoverPreviewElement) {
                        hoverPreviewElement = document.createElement('div');
                        hoverPreviewElement.className = 'item-hover-preview';
                        document.body.appendChild(hoverPreviewElement);
                    }
                    
                    // Get category for icon styling
                    const category = itemData.category || 'unknown';
                    const categoryIcon = getCategoryIcon(category);
                    
                    // Build preview content
                    hoverPreviewElement.innerHTML = `
                        <div class="item-hover-preview-icon ${category}">
                            ${categoryIcon}
                        </div>
                        <div class="item-hover-preview-text">
                            ${itemData.displayName}
                        </div>
                    `;
                    
                    // Position preview near cursor
                    const rect = element.getBoundingClientRect();
                    const previewWidth = 120;
                    const previewHeight = 120;
                    
                    let left = rect.right + 10; // 10px offset from element
                    let top = rect.top;
                    
                    // Adjust if preview would go off screen
                    if (left + previewWidth > window.innerWidth) {
                        left = rect.left - previewWidth - 10; // Show on left side
                    }
                    
                    if (top + previewHeight > window.innerHeight) {
                        top = window.innerHeight - previewHeight - 10;
                    }
                    
                    hoverPreviewElement.style.left = `${left}px`;
                    hoverPreviewElement.style.top = `${top}px`;
                    hoverPreviewElement.classList.add('visible');
                    
                } catch (e) {
                    console.warn('Could not show item preview:', e);
                }
            }, 100); // 100ms delay - much faster
        }

        function hideItemPreview() {
            clearTimeout(hoverPreviewTimeout);
            
            if (hoverPreviewElement) {
                hoverPreviewElement.classList.remove('visible');
            }
        }

        function getCategoryIcon(category) {
            const icons = {
                'weapons': '‚öî',
                'handguns': 'üî´',
                'launchers': 'üöÄ',
                'backpacks': 'üéí',
                'vests': 'üõ°',
                'attachments': 'üîß',
                'magazines': 'üì¶',
                'unknown': '‚ùì'
            };
            return icons[category] || icons['unknown'];
        }

        // Global functions for buttons and tree interaction
        window.regenerateData = regenerateData;
        window.runGrouping = runGrouping;
        window.clearSelection = clearSelection;
        window.selectItem = selectItem;
        window.toggleTreeGroup = toggleTreeGroup;
        window.selectTreeItem = selectTreeItem;
        window.toggleInheritanceView = toggleInheritanceView;
        window.setViewMode = setViewMode;
        window.expandAllGroups = expandAllGroups;
        window.collapseAllGroups = collapseAllGroups;
        window.toggleFilter = toggleFilter;
        window.clearAllFilters = clearAllFilters;
        window.toggleSortOrder = toggleSortOrder;
        window.toggleExpandCollapse = toggleExpandCollapse;
        window.toggleFilterPanel = toggleFilterPanel;
        window.toggleStatsPanel = toggleStatsPanel;
        window.toggleOptionsPanel = toggleOptionsPanel;
        window.togglePreviewIcon = togglePreviewIcon;
        window.toggleModIcon = toggleModIcon;
        window.changeSpacing = changeSpacing;
        window.showItemPreview = showItemPreview;
        window.hideItemPreview = hideItemPreview;
        window.updateGrouping = updateGrouping;
        

        // Event listeners for new UI controls
        document.getElementById('sortingSelect').addEventListener('change', (e) => {
            renderTreeView(filteredItems, 'leftTreeView');
        });
        
        
        // Group by radio button listeners (now in Options panel)
        document.querySelectorAll('input[name="groupByOption"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.checked) {
                    updateGrouping(e.target.value);
                }
            });
        });
        
        
        // View mode radio button listeners (now in Options panel)
        document.querySelectorAll('input[name="viewMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.checked) {
                    setViewMode(e.target.value);
                }
            });
        });

        // Variant filter radio button listeners
        document.querySelectorAll('input[name="variantFilter"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                activeFilters.variants = e.target.value;
                updateFilteredItems();
            });
        });
        
        // Category tab listeners
        document.querySelectorAll('.category-tab').forEach(tab => {
            tab.addEventListener('click', () => switchCategory(tab.dataset.category));
        });

        // Right panel tab listeners
        document.querySelectorAll('.attachment-tab').forEach(tab => {
            tab.addEventListener('click', () => switchRightCategory(tab.dataset.attachment));
        });

        // Search functionality
        document.getElementById('leftSearch').addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            const baseItems = filterItemsByCategory(selectedCategory);
            const items = baseItems.filter(item => item.displayName.toLowerCase().includes(searchTerm));
            renderTreeView(items, 'leftTreeView');
        });

        document.getElementById('rightSearch').addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            const items = filterItemsByCategory(selectedRightCategory)
                .filter(item => item.displayName.toLowerCase().includes(searchTerm));
            renderTreeView(items, 'rightTreeView', false);
        });

        // Async initialization function
        async function initializeArsenal() {
            // Show loading message
            document.getElementById('timing').textContent = 'Loading data...';
            
            try {
                // Load data asynchronously
                const items = await getMockItems();
                currentItems = [...items];
                filteredItems = [...items];
                
                // Initialize UI state
                switchCategory('weapons');
                switchRightCategory('attachments');
                
                // Set initial expand state based on variant view default
                // Since variant view creates groups, they should start expanded
                currentExpandState = true;
                const button = document.getElementById('treeToggleBtn');
                const text = document.getElementById('treeToggleText');
                if (button && text) {
                    button.textContent = '‚àí';
                    text.textContent = 'Collapse All';
                }
                
                // Initialize toggle visibility for default hierarchy view
                setViewMode('hierarchy');
                
                // Initialize keyboard navigation for both panels
                initializeKeyboardNavigation('leftTreeView');
                initializeKeyboardNavigation('rightTreeView');
                
                // Initialize spacing classes on tree views
                changeSpacing('general'); // Set initial spacing
                
                // Sync initial checkbox states with displayOptions
                document.getElementById('showPreviewIcon').checked = displayOptions.showPreviewIcon;
                document.getElementById('showModIcon').checked = displayOptions.showModIcon;
                document.querySelector(`input[name="spacingOption"][value="${displayOptions.spacing}"]`).checked = true;


                console.log('üéØ ACE3 Arsenal Simulation Ready!');
                console.log('üí° Select a weapon to see compatible attachments and magazines.');
                console.log('üìä Items loaded:', {
                    weapons: currentItems.filter(i => i.category === 'weapons').length,
                    handguns: currentItems.filter(i => i.category === 'handguns').length,
                    launchers: currentItems.filter(i => i.category === 'launchers').length,
                    attachments: currentItems.filter(i => i.category === 'attachments').length,
                    magazines: currentItems.filter(i => i.category === 'magazines').length,
                    backpacks: currentItems.filter(i => i.category === 'backpacks').length,
                    vests: currentItems.filter(i => i.category === 'vests').length
                });
                
                // Debug: Check some sample items have the right data
                const sampleWeapon = currentItems.find(i => i.category === 'weapons');
                const sampleMagazine = currentItems.find(i => i.category === 'magazines');
                const sampleAttachment = currentItems.find(i => i.category === 'attachments');
                
                console.log('üî´ Sample weapon:', sampleWeapon?.displayName, 'magazineWells:', sampleWeapon?.magazineWells, 'weaponSlots:', sampleWeapon?.weaponSlots);
                console.log('üì¶ Sample magazine:', sampleMagazine?.displayName, 'magazineWells:', sampleMagazine?.magazineWells);
                console.log('üîß Sample attachment:', sampleAttachment?.displayName, 'weaponSlots:', sampleAttachment?.weaponSlots);
                
                // Debug: Check all magazines for magazineWells data
                const allMagazines = currentItems.filter(i => i.category === 'magazines');
                console.log('üì¶ Total magazines:', allMagazines.length);
                console.log('üì¶ Magazines with magazineWells:', allMagazines.filter(m => m.magazineWells && m.magazineWells.length > 0).length);
                console.log('üì¶ Sample magazine data:', allMagazines.slice(0, 3).map(m => ({
                    name: m.displayName,
                    magazineWells: m.magazineWells,
                    caliber: m.caliber
                })));
                
                document.getElementById('timing').textContent = 'Ready';
                
            } catch (error) {
                console.error('üö® Failed to load arsenal data:', error);
                
                // Show user-friendly error message
                const timing = document.getElementById('timing');
                timing.textContent = 'Error loading data';
                timing.style.color = '#ff4444';
                timing.style.cursor = 'pointer';
                timing.title = `Click for details: ${error.message}`;
                
                // Show error in left panel
                const leftTreeView = document.getElementById('leftTreeView');
                if (leftTreeView) {
                    leftTreeView.innerHTML = `
                        <div style="padding: 20px; color: #ff4444; text-align: center;">
                            <h3>‚ö†Ô∏è Data Loading Error</h3>
                            <p style="margin: 10px 0; font-size: 12px;">${error.message}</p>
                            <p style="font-size: 10px; color: #999;">Check browser console for details</p>
                            <button onclick="location.reload()" style="margin-top: 10px; padding: 5px 10px; background: #333; color: #fff; border: 1px solid #666; border-radius: 3px; cursor: pointer;">
                                Reload Page
                            </button>
                        </div>
                    `;
                }
                
                // Optional: Show error details on click
                timing.onclick = () => {
                    alert(`Arsenal Loading Error:\n\n${error.message}\n\nCheck the browser console (F12) for more details.`);
                };
            }
        }
        
        // Initialize the application
        initializeArsenal();

    </script>
</body>
</html>